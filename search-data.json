[{"url":"https://lusito.github.io/tsx-dom/","content":"Lightweight DOM Libraries\n\nIncluded Projects\n\ntsx-dom\nA simple way to use tsx syntax to create native dom elements using document.createElement.\ntsx-dom-ssr\nThe same as above, but aimed at Server-Side-Rendering by allowing async data fetching.\ntsx-dom-types\nThis project is here, so that other projects like tsx-dom and tsx-dom-ssr can use the types independently.\ndom-helmet\nThis is a helper similar to react-helmet.\nIt can be used on a generated DOM tree to adjust the topmost <head>, <body> and <html> tags.\nThis can be useful in server-side-rendering when component logic needs to adjust the <head>, <body> or <html> tag.\nscatman\nLightning fast navigation on pages that are mostly static. Forked off of swup, heavily refactored and ported to TypeScript.\n\nDemo Projects\n\ntsx-dom-demo\nA simple To-Do list showing one way you might use tsx-dom.\ntsx-dom-ssr-demo\nA more complex demo showcasing tsx-dom-ssr with the Rick and Morty API\n\nReport Issues\nSomething not working quite as expected? Do you need a feature that has not been implemented yet? Check the issue tracker and add a new one if your problem is not already listed. Please try to provide a detailed description of your problem, including the steps to reproduce it.\nContribute\nAwesome! If you would like to contribute with a new feature or submit a bugfix, fork this repo and send a pull request. Please, make sure all the unit tests are passing before submitting and add new ones in case you introduced new features.\nLicense\ntsx-dom has been released under the MIT license, meaning you\ncan use it free of charge, without strings attached in commercial and non-commercial projects. Credits are appreciated but not mandatory.\n","title":"Lightweight DOM Libraries"},{"url":"https://lusito.github.io/tsx-dom/dom-helmet/","content":"dom-helmet\n\nA document head manager for plain dom (inspired by react-helmet).\n\nIt can be used on a generated DOM tree to adjust the topmost head, body and html tags.\nThis can be useful in server-side-rendering when component logic needs to adjust the head, body or html tag.\nThere's also the possibility of using portals to transfer any element from one place to another!\n\nHow to Use\nCheck out the documentation\nReport Issues\nSomething not working quite as expected? Do you need a feature that has not been implemented yet? Check the issue tracker and add a new one if your problem is not already listed. Please try to provide a detailed description of your problem, including the steps to reproduce it.\nContribute\nAwesome! If you would like to contribute with a new feature or submit a bugfix, fork this repo and send a pull request. Please, make sure all the unit tests are passing before submitting and add new ones in case you introduced new features.\nLicense\ndom-helmet has been released under the MIT license, meaning you\ncan use it free of charge, without strings attached in commercial and non-commercial projects. Credits are appreciated but not mandatory.\n","title":"dom-helmet","projectIndex":{"title":"dom-helmet","url":"https://lusito.github.io/tsx-dom/dom-helmet/"}},{"url":"https://lusito.github.io/tsx-dom/dom-helmet/setup.html","content":"Setup\nInstall via NPM\nnpm i dom-helmet\n\n","title":"Setup","projectIndex":{"title":"dom-helmet","url":"https://lusito.github.io/tsx-dom/dom-helmet/"}},{"url":"https://lusito.github.io/tsx-dom/dom-helmet/supported-tags.html","content":"Supported Tags\nHead Tags\n\nAll elements matching html > body head will be moved into html > head.\nDuplicates will be removed if not within the same (false) head element:\n\nTags: title, base, meta, link, script (with src attribute) and any tag with a matching id attribute\n\n\nFinally the false head elements will be removed.\n\nBody Tags\n\nAll elements matching html > body body will be moved into html > body.\nAttributes from these false body tags will be transferred to html > body\n\nClasses and styles will be appended, other attributes will replace the previous value.\n\n\nFinally the false body elements will be removed.\n\nHTML Tags\n\nAttributes from false html tags (matching html html) will be transferred to the root html element.\n\nClasses and styles will be appended, other attributes will replace the previous value.\n\n\nFinally the false html elements will be removed.\n\nPortals and Destinations\nSince it's all about transferring items from one place to another, here's a little bonus:\n\nAll elements matching html > body helmet-portal will be moved to a respective html > body helmet-destination.\nFor example, the <helmet-portal to=\"my-target\"> element will transfer its children to a respective <helmet-destination id=\"my-target\"> element.\nDuplicates will be removed if not within the same helmet-portal element:\n\nAny tag with a matching id attribute\n\n\nIf a matching helmet-destination element is not found, the children will stay at their original location.\nBoth <helmet-portal> and <helmet-destination> elements will disappear in the result, leaving only their children behind.\n\nUsage with tsx-dom(-ssr)\nIf you want to use <helmet-portal> and <helmet-destination> with tsx-dom or tsx-dom-ssr, you'll need to tell typescript that these tags exist and what properties they accept.\nFor tsx-dom this looks like this:\nimport { CustomElementProps } from \"tsx-dom\";\nimport { HelmetPortalProps, HelmetDestinationProps } from \"dom-helmet\";\n\ndeclare module \"tsx-dom\" {\n  interface CustomElementsHTML {\n    \"helmet-portal\": CustomElementProps<HelmetPortalProps, null>;\n    \"helmet-destination\": CustomElementProps<HelmetDestinationProps, null>;\n  }\n}\n\nReplace tsx-dom with tsx-dom-ssr if you use that it instead.\n","title":"Supported Tags","projectIndex":{"title":"dom-helmet","url":"https://lusito.github.io/tsx-dom/dom-helmet/"}},{"url":"https://lusito.github.io/tsx-dom/dom-helmet/usage.html","content":"Usage\nimport { domHelmet } from \"dom-helmet\";\n\n// domHelmet expects 3 dom-nodes, which will be modified in-place:\ndomHelmet({\n    html: ...,\n    head: ...,\n    body: ...,\n});\n\nExample\nThis:\n<html class=\"initial\">\n  <head>\n    <title>Initial Title</title>\n    <meta charset=\"utf-8\" />\n  </head>\n  <body class=\"initial\">\n    <div>\n      <html class=\"html-more\"></html>\n      <head>\n        <title>Changed Title</title>\n        <meta charset=\"utf-16\" />\n      </head>\n      <body class=\"body-more\">\n        <div>Some Dialog</div>\n      </body>\n      Some Content\n    </div>\n  </body>\n</html>\n\nWill turn into this:\n<html class=\"initial html-more\">\n  <head>\n    <title>Changed Title</title>\n    <meta charset=\"utf-16\" />\n  </head>\n  <body class=\"initial body-more\">\n    <div>Some Content</div>\n    <div>Some Dialog</div>\n  </body>\n</html>\n\n","title":"Usage","projectIndex":{"title":"dom-helmet","url":"https://lusito.github.io/tsx-dom/dom-helmet/"}},{"url":"https://lusito.github.io/tsx-dom/scatman/","content":"scatman\n\nLightning fast navigation on pages that are mostly static. Forked off of swup, heavily refactored and ported to TypeScript.\nHow to Use\nCheck out the documentation\nReport Issues\nSomething not working quite as expected? Do you need a feature that has not been implemented yet? Check the issue tracker and add a new one if your problem is not already listed. Please try to provide a detailed description of your problem, including the steps to reproduce it.\nContribute\nAwesome! If you would like to contribute with a new feature or submit a bugfix, fork this repo and send a pull request. Please, make sure all the unit tests are passing before submitting and add new ones in case you introduced new features.\nLicense\nscatman has been released under the MIT license, meaning you\ncan use it free of charge, without strings attached in commercial and non-commercial projects. Credits are appreciated but not mandatory.\n","title":"scatman","projectIndex":{"title":"scatman","url":"https://lusito.github.io/tsx-dom/scatman/"}},{"url":"https://lusito.github.io/tsx-dom/scatman/setup.html","content":"Setup\nInstall via NPM\nnpm i scatman\n\nExamples on how to use it will follow.\n","title":"Setup","projectIndex":{"title":"scatman","url":"https://lusito.github.io/tsx-dom/scatman/"}},{"url":"https://lusito.github.io/tsx-dom/tsx-dom/","content":"tsx-dom\n\nA simple way to use tsx syntax to create native dom elements using document.createElement.\nThis project has taken definitions from preact from Jason Miller as a starting point.\nWhy?\nI work on a couple of web-extensions. These extensions have no server side, so creating a UI needs to be done with HTML or JavaScript. Since React and the likes add to the size of the project and are not as performant as I need them to be (especially on older mobile devices), I needed a different approach to split the UI into components to keep it manageable.\nAlso using innerHTML and the likes should be forbidden, since it's not allowed in the mozilla review processes.\nThis project allows you to create a UI using react-like components, without including react.\nHow to Use\nCheck out the documentation\nReport Issues\nSomething not working quite as expected? Do you need a feature that has not been implemented yet? Check the issue tracker and add a new one if your problem is not already listed. Please try to provide a detailed description of your problem, including the steps to reproduce it.\nContribute\nAwesome! If you would like to contribute with a new feature or submit a bugfix, fork this repo and send a pull request. Please, make sure all the unit tests are passing before submitting and add new ones in case you introduced new features.\nLicense\ntsx-dom has been released under the MIT license, meaning you\ncan use it free of charge, without strings attached in commercial and non-commercial projects. Credits are appreciated but not mandatory.\n","title":"tsx-dom","projectIndex":{"title":"tsx-dom","url":"https://lusito.github.io/tsx-dom/tsx-dom/"}},{"url":"https://lusito.github.io/tsx-dom/tsx-dom/configuration.html","content":"Configuration\nLimiting Types\nBy default, support for HTML and SVG Elements is enabled. You can limit this\n(for example to do less casting or to prevent certain tags from being used)\nby creating a d.ts file (e.g. tsx-dom-config.d.ts), in your source folder with this content:\nimport \"tsx-dom\";\n\ndeclare module \"tsx-dom\" {\n  export interface TsxConfig {\n    // Set one of these to false to disable support for them\n    svg: false;\n    // html: false;\n  }\n}\n\nA configuration like this will just limit the possible types. It does not affect the code in any way.\n","title":"Configuration","projectIndex":{"title":"tsx-dom","url":"https://lusito.github.io/tsx-dom/tsx-dom/"}},{"url":"https://lusito.github.io/tsx-dom/tsx-dom/components.html","content":"Components\nFunctional Components\nSimilar to React, you can have functional components with properties:\ninterface ButtonProps {\n  text: string;\n}\n\nfunction Button({ text }: ButtonProps) {\n  return <button class=\"my-button\">{text}</button>;\n}\n\ndocument.body.appendChild(<Button text=\"Click me\" />);\n\nWith Children\nOf course, you can also pass down children:\nimport { BaseProps } from \"tsx-dom\";\n\ninterface ButtonProps extends BaseProps {\n  variant: \"primary\" | \"secondary\";\n}\n\nfunction Button({ variant, children }: ButtonProps) {\n  return <button class={`my-button my-button-${variant}`}>{children}</button>;\n}\n\ndocument.body.appendChild(<Button variant=\"primary\">Click Me</Button>);\n\nArrow Functions\nOf course, you can also use arrow functions. There's a type FC to help with that:\nimport { BaseProps, FC } from \"tsx-dom\";\n\ninterface ButtonProps extends BaseProps {\n  variant: \"primary\" | \"secondary\";\n}\n\nconst Button: FC<ButtonProps> = ({ variant, children }) => (\n  <button class={`my-button my-button-${variant}`}>{children}</button>\n);\n\ndocument.body.appendChild(<Button variant=\"primary\">Click Me</Button>);\n\n","title":"Components","projectIndex":{"title":"tsx-dom","url":"https://lusito.github.io/tsx-dom/tsx-dom/"}},{"url":"https://lusito.github.io/tsx-dom/tsx-dom/custom-elements.html","content":"Custom Elements\nIn case you want to write custom elements, there are multiple ways you can do that in tsx-dom.\nBy Using defineCustomElements\nThe simplest is with the defineCustomElements helper. defineCustomElements works just like customElements.define.\nThe only difference is, that it returns a functional component you can use in your JSX.\nWithout Extending an Existing Element\nimport { defineCustomElement } from \"tsx-dom\";\n\ntype MyCustomElementProps = {\n  logMessage: string;\n};\n\nexport const MyCustomElement = defineCustomElement<MyCustomElementProps>(\n  \"my-custom-element\",\n  class extends HTMLElement {\n    connectedCallback() {\n      console.log(\"connected\", this.getAttribute(\"logMessage\"));\n    }\n    // ...\n  },\n);\n\ndocument.body.appendChild(<MyCustomElement logMessage=\"Hello there!\" />);\n\nWhen Extending an Existing Element\nimport { defineCustomElement } from \"tsx-dom\";\n\ntype MyCustomSelectProps = {\n  logMessage: string;\n};\n\nexport const MyCustomSelect = defineCustomElement<MyCustomSelectProps, \"select\">(\n  \"my-custom-select\",\n  class extends HTMLSelectElement {\n    connectedCallback() {\n      console.log(\"connected\", this.getAttribute(\"logMessage\"));\n    }\n    // ...\n  },\n  { extends: \"select\" },\n);\n\ndocument.body.appendChild(<MyCustomSelect disabled logMessage=\"Hello there!\" />);\n\nBy Declaring JSX Types\nThe above only works if you write the custom element code yourself.\nIf you use an existing custom-element, you can use the method below.\nYou can write the HTML as you normally would:\ndocument.body.appendChild(<my-custom-element logMessage=\"Hello there!\" />);\n\nIn order to do that, we need to extend the JSX Types by using the CustomElementProps helper.\nWithout Extending an Existing Element\nimport { CustomElementProps } from \"tsx-dom\";\n\nclass MyCustomElement extends HTMLElement {\n  connectedCallback() {\n    console.log(\"connected\", this.getAttribute(\"logMessage\"));\n  }\n  // ...\n}\n\ncustomElements.define(\"my-custom-element\", MyCustomElement);\n\ntype MyCustomElementProps = {\n  logMessage: string;\n};\n\ndeclare module \"tsx-dom\" {\n  interface CustomElementsHTML {\n    \"my-custom-element\": CustomElementProps<MyCustomElementProps, null>;\n  }\n}\n\ndocument.body.appendChild(<my-custom-element logMessage=\"Hello there!\" />);\n\nWhen Extending an Existing Element\nimport { CustomElementProps } from \"tsx-dom\";\n\nclass MyCustomSelect extends HTMLSelectElement {\n  connectedCallback() {\n    console.log(\"connected\", this.getAttribute(\"logMessage\"));\n  }\n  // ...\n}\n\ncustomElements.define(\"my-custom-element\", MyCustomSelect, { extends: \"select\" });\n\ntype MyCustomSelectProps = {\n  logMessage: string;\n};\n\ndeclare module \"tsx-dom\" {\n  interface CustomElementsHTML {\n    \"my-custom-select\": CustomElementProps<MyCustomSelectProps, \"select\">;\n  }\n}\n\ndocument.body.appendChild(\n  <my-custom-select disabled logMessage=\"Hello there!\">\n    <option value=\"foo\">Foo</option>\n    <option value=\"bar\">Bar</option>\n  </my-custom-select>,\n);\n\nThe is Attribute vs tsxTag\nLet's say you have a custom element word-count, but it should fall back to a p tag when the custom-element has not been registered (yet).\nNormally, you would do it like this:\n<p is=\"word-count\"></p>\n\nThis tells the browser it's a p tag, but execute the code for word-count on it, once it's defined.\nThis won't work properly with tsx-dom, as you will get no intellisense for the respective props of that custom element.\nIn order to solve this issue, we have the tsxTag attribute, which does the exact inverse:\nconst element = <word-count tsxTag=\"p\" />;\n\nBy doing this, you'll get the correct props while writing the JSX syntax, but the generated HTML will still be:\n<p is=\"word-count\"></p>\n\n","title":"Custom Elements","projectIndex":{"title":"tsx-dom","url":"https://lusito.github.io/tsx-dom/tsx-dom/"}},{"url":"https://lusito.github.io/tsx-dom/tsx-dom/html-tags.html","content":"HTML Tags\nExample\nThe h import is not needed if you use the new JSX Transform!\n// import { h } from \"tsx-dom\";\n\n// jsx tags (<...>) always return an HTMLElement, so cast it to whatever type you need\nconst myImg = (<img src=\"my/path.png\" onClick={() => console.log(\"click\")} />) as HTMLImageElement;\n\n// Use it like any element created with document.createElement(...);\ndocument.body.appendChild(myImg);\n\nAttributes and Event Handlers\nAttributes on plain dom starting with a lowercase \"on\" and followed by an uppercase character will be added as event listeners. If the attribute ends with \"Capture\", then the capture parameter will be set to true. For example onClickCapture={fn} will result in element.addEventListener(\"click\", fn, true).\nOther attributes will be set via element.setAttribute(). Passing true as a value is the same as passing the attribute name as value.\nSpecial Attributes\nSome Attributes have special handling:\n\nclass can be specified either as string, Record<string, boolean> or Array of both. null, undefined and false are valid values as well. Only truthy values count and duplicates will be filtered.\nstyle can be specified either as string or as Object. The latter has obviously the benefit of autocompletion and type checking.\ninnerHTML can only be specified via dangerouslySetInnerHTML, as you should normally avoid this.\n__source and __self have special meaning in JSX and will be ignored. You shouldn't use anything with __ prefix anyway.\nref can be used to connect the element to a reference. See Referencing Elements\n\nChildren\nYou can add as many children as you like. Even deeply nested arrays are allowed.\nconst danger = \"Danger\";\nconst someArray = [\"Whoop\", \"Dee\", \"Doo\", 0, 1, 2, [\"nested\", [<i>deeply</i>]]];\nconst el = (\n  <div>\n    <img src=\"danger.png\" />\n    Will Robinson,\n    {danger}\n    <b>!!!</b>\n    <p>{someArray}</p>\n  </div>\n);\n\nAs you can see in the example above, even variables can be inserted as children. Arrays will be expanded. Falsey values (except 0) will be ignored. HTMLElement values will be appended as is, string or number values will become text-nodes.\n","title":"HTML Tags","projectIndex":{"title":"tsx-dom","url":"https://lusito.github.io/tsx-dom/tsx-dom/"}},{"url":"https://lusito.github.io/tsx-dom/tsx-dom/referencing-elements.html","content":"Referencing Elements\nAt some point you'll want to access the element itself to read from it or modify it.\nBy Storing the JSX Result\nThis is the easiest way to store a reference:\nexport function MyForm() {\n  const input = <input placeholder=\"Enter a message to send...\" />;\n\n  const onSubmit = (e: SubmitEvent) => {\n    e.preventDefault();\n    e.stopPropagation();\n\n    if (input.value) {\n      console.log(input.value);\n      input.value = \"\";\n    }\n  };\n\n  return (\n    <form onSubmit={onSubmit}>\n      {input}\n      <button>Send</button>\n    </form>\n  );\n}\n\nUsing createRef\nThe above example can get quite ugly to read if you have to extract every element to a higher place.\nYou might be used to useRef from React. tsx-dom has a similar concept (createRef):\nexport function MyForm() {\n  const input = createRef<HTMLInputElement>();\n\n  const onSubmit = (e: SubmitEvent) => {\n    e.preventDefault();\n    e.stopPropagation();\n\n    // Be aware, that input.current will be set after the JSX has been transformed,\n    // so TypeScript can't know if it's non-null at this point.\n    // But as long as this function is not called before the return statement, input.current will not be null here.\n    if (input.current?.value) {\n      console.log(input.current.value);\n      input.current.value = \"\";\n    }\n  };\n\n  return (\n    <form onSubmit={onSubmit}>\n      <input placeholder=\"Enter a message to send...\" ref={input} />\n      <button>Send</button>\n    </form>\n  );\n}\n\n","title":"Referencing Elements","projectIndex":{"title":"tsx-dom","url":"https://lusito.github.io/tsx-dom/tsx-dom/"}},{"url":"https://lusito.github.io/tsx-dom/tsx-dom/setup.html","content":"Setup\nInstall via NPM\nnpm i tsx-dom\n\nEnable TSX parsing in your tsconfig.json:\n{\n  \"compilerOptions\": {\n    \"jsx\": \"react\",\n    \"jsxFactory\": \"h\"\n    // ...\n  }\n  // ...\n}\n\nOr with the new JSX Transform:\n{\n  \"compilerOptions\": {\n    \"jsx\": \"react-jsx\",\n    \"jsxImportSource\": \"tsx-dom\"\n    // ...\n  }\n  // ...\n}\n\n","title":"Setup","projectIndex":{"title":"tsx-dom","url":"https://lusito.github.io/tsx-dom/tsx-dom/"}},{"url":"https://lusito.github.io/tsx-dom/tsx-dom-ssr/","content":"tsx-dom-ssr\n\nA simple way to use tsx syntax to do async server-side-rendering using document.createElement.\nHow to Use\nCheck out the documentation\nReport Issues\nSomething not working quite as expected? Do you need a feature that has not been implemented yet? Check the issue tracker and add a new one if your problem is not already listed. Please try to provide a detailed description of your problem, including the steps to reproduce it.\nContribute\nAwesome! If you would like to contribute with a new feature or submit a bugfix, fork this repo and send a pull request. Please, make sure all the unit tests are passing before submitting and add new ones in case you introduced new features.\nLicense\ntsx-dom-ssr has been released under the MIT license, meaning you\ncan use it free of charge, without strings attached in commercial and non-commercial projects. Credits are appreciated but not mandatory.\n","title":"tsx-dom-ssr","projectIndex":{"title":"tsx-dom-ssr","url":"https://lusito.github.io/tsx-dom/tsx-dom-ssr/"}},{"url":"https://lusito.github.io/tsx-dom/tsx-dom-ssr/components.html","content":"Components\nFunctional Components\nSimilar to React, you can have functional components with properties:\ninterface ButtonProps {\n  text: string;\n}\n\nfunction Button({ text }: ButtonProps) {\n  return <button class=\"my-button\">{text}</button>;\n}\n\nconst child = <Button text=\"Click me\" />;\n\nWith Children\nOf course, you can also pass down children:\nimport { BaseProps } from \"tsx-dom-ssr\";\n\ninterface ButtonProps extends BaseProps {\n  variant: \"primary\" | \"secondary\";\n}\n\nfunction Button({ variant, children }: ButtonProps) {\n  return <button class={`my-button my-button-${variant}`}>{children}</button>;\n}\n\nconst child = <Button variant=\"primary\">Click Me</Button>;\n\nArrow Functions\nOf course, you can also use arrow functions. There's a type FC to help with that:\nimport { BaseProps, FC } from \"tsx-dom-ssr\";\n\ninterface ButtonProps extends BaseProps {\n  variant: \"primary\" | \"secondary\";\n}\n\nconst Button: FC<ButtonProps> = ({ variant, children }) => (\n  <button class={`my-button my-button-${variant}`}>{children}</button>\n);\n\nconst child = <Button variant=\"primary\">Click Me</Button>;\n\nAsync Functions\nAnd of course the big benefit of tsx-dom-ssr is to be able to render things asynchronously:\nasync function TodoList() {\n  const todos = await fetchTodos();\n\n  return (\n    <ul>\n      {todos.map((todo) => (\n        <li>{todo}</li>\n      ))}\n    </ul>\n  );\n}\n\nconst child = <TodoList />;\n\n","title":"Components","projectIndex":{"title":"tsx-dom-ssr","url":"https://lusito.github.io/tsx-dom/tsx-dom-ssr/"}},{"url":"https://lusito.github.io/tsx-dom/tsx-dom-ssr/configuration.html","content":"Configuration\nLimiting Types\nBy default, support for HTML and SVG Elements is enabled. You can limit this (to prevent certain tags from being used)\nby creating a d.ts file (e.g. tsx-dom-ssr-config.d.ts), in your source folder with this content:\nimport \"tsx-dom-ssr\";\n\ndeclare module \"tsx-dom-ssr\" {\n  export interface TsxConfig {\n    // Set one of these to false to disable support for them\n    svg: false;\n    // html: false;\n  }\n}\n\nA configuration like this will just limit the possible types. It does not affect the code in any way.\n","title":"Configuration","projectIndex":{"title":"tsx-dom-ssr","url":"https://lusito.github.io/tsx-dom/tsx-dom-ssr/"}},{"url":"https://lusito.github.io/tsx-dom/tsx-dom-ssr/custom-elements.html","content":"Custom Elements\nIn case you want to write custom elements, this describes how you can do that in tsx-dom-ssr.\nBy Declaring JSX Types\nWe need to extend the JSX Types by using the CustomElementProps helper.\nWithout Extending an Existing Element\nImagine you have the following frontend code somewhere:\nclass MyCustomElement extends HTMLElement {\n  connectedCallback() {\n    console.log(\"connected\", this.getAttribute(\"logMessage\"));\n  }\n  // ...\n}\n\ncustomElements.define(\"my-custom-element\", MyCustomElement);\n\nYou'll need to define the types in your backend code before you can write the JSX for it:\nimport { CustomElementProps } from \"tsx-dom-ssr\";\n\ntype MyCustomElementProps = {\n  logMessage: string;\n};\n\ndeclare module \"tsx-dom-ssr\" {\n  interface CustomElementsHTML {\n    \"my-custom-element\": CustomElementProps<MyCustomElementProps, null>;\n  }\n}\n\nconst child = <my-custom-element logMessage=\"Hello there!\" />;\n\nWhen Extending an Existing Element\nImagine you have frontend code, which extends an existing element:\nclass MyCustomSelect extends HTMLSelectElement {\n  connectedCallback() {\n    console.log(\"connected\", this.getAttribute(\"logMessage\"));\n  }\n  // ...\n}\n\ncustomElements.define(\"my-custom-element\", MyCustomSelect, { extends: \"select\" });\n\nYou'll need to define the types in your backend code before you can write the JSX for it:\nimport { CustomElementProps } from \"tsx-dom-ssr\";\n\ntype MyCustomSelectProps = {\n    logMessage: string;\n};\n\ndeclare module \"tsx-dom-ssr\" {\n    interface CustomElementsHTML {\n        \"my-custom-select\": CustomElementProps<MyCustomSelectProps, \"select\">;\n    }\n}\n\nconst child = (\n    <my-custom-select disabled logMessage=\"Hello there!\">\n        <option value=\"foo\">Foo</option>\n        <option value=\"bar\">Bar</option>\n    </my-custom-select>,\n);\n\nThe is Attribute vs tsxTag\nLet's say you have a custom element word-count, but it should fall back to a p tag when the custom-element has not been registered (yet).\nNormally, you would do it like this:\n<p is=\"word-count\"></p>\n\nThis tells the browser it's a p tag, but execute the code for word-count on it, once it's defined.\nThis won't work properly with tsx-dom, as you will get no intellisense for the respective props of that custom element.\nIn order to solve this issue, we have the tsxTag attribute, which does the exact inverse:\nconst child = <word-count tsxTag=\"p\" />;\n\nBy doing this, you'll get the correct props while writing the JSX syntax, but the generated HTML will still be:\n<p is=\"word-count\"></p>\n\n","title":"Custom Elements","projectIndex":{"title":"tsx-dom-ssr","url":"https://lusito.github.io/tsx-dom/tsx-dom-ssr/"}},{"url":"https://lusito.github.io/tsx-dom/tsx-dom-ssr/external-problems.html","content":"External Problems\nSome things are just out of scope for this library. Here you'll find some ideas what to do when you get to the point.\n(Dev-) Server\ntsx-dom-ssr doesn't provide a server and it never will. It's all about rendering the DOM.\nYou can easily use fastify, express.js or similar. With nx you can easily set up a monorepo just like this one.\nIt's even possible to easily set up simple hot reload functionality.\nRouting\nIt's currently not planned to support routing. Since this project is aimed at server-side-rendering,\nrouting will happen with your server mostly. You can easily do routing yourself by providing a context and using that context to selectively render things.\nAdding Styles\nYou can set inline-styles directly on the html elements in a css-in-js ish way.\nI wouldn't recommend it though, since it drastically increases html size among other reasons.\nMy recommendation is to use CSS-Modules (rendered as style tags), see the tsx-dom-ssr-demo project.\n\nIt increases the HTML size compared to linked styles, but:\nIt improves page rendering.\nIt only renders the styles actually used.\nIt avoids naming conflicts.\nIt works nicely with pre- & post-processors for webpack (for example scss).\n\nIf you want some css-in-js approach (like styled-components), you'll have to implement that yourself for now.\nI'm open for suggestions, but that's currently not my focus on this project.\nAnother alternative that might work is going for Tailwind. I haven't tried it yet, but I hear good things.\n🗲 AMP-Mode\nYou want to create AMP compatible HTML?\nBy doing querySelector on the DOM-nodes after rendering, you could easily search for nodes that are not allowed\nand then remove or replace them with an AMP version.\nReact-Helmet Functionality\nSince everything is rendered into DOM, one can easily query the DOM and modify it.\nA simple implementation is provided in this monorepo with the dom-helmet library.\nTimeouts\nYou can use the (experimental) AbortController and a setTimeout().\nError-boundaries can be used to catch the errors caused by the abort.\nFast Page Transitions\nTry scatman, swup, @hotwired/turbo or barba.js\nClient-Side Code\nTry using custom-elements as shown with the project tsx-dom-ssr-demo.\nYou can use an SPA framework for the clientside code, but I strongly recommend to take a lightweight approach on client code.\nOtherwise you might as well just use any of the existing SPA frameworks, that support SSR.\n","title":"External Problems","projectIndex":{"title":"tsx-dom-ssr","url":"https://lusito.github.io/tsx-dom/tsx-dom-ssr/"}},{"url":"https://lusito.github.io/tsx-dom/tsx-dom-ssr/html-tags.html","content":"HTML Tags\nPreparations\nBefore you can write any JSX, you'll need a function to render it to HTML.\ntsx-dom-ssr by itself only gives you a function toDom, which returns a DocumentFragment.\nHere is a very simple render function to create HTML:\nimport { ComponentChildren, addAbortSignal, toDom } from \"tsx-dom-ssr\";\n\ndeclare module \"tsx-dom-ssr\" {\n  export interface ComponentThis {\n    foo: string;\n  }\n}\n\nexport async function renderHTML(children: ComponentChildren) {\n  const abortController = new AbortController();\n\n  let dom: DocumentFragment;\n  try {\n    dom = await toDom(document, children, addAbortSignal({ foo: \"bar\" }, abortController));\n  } catch (e) {\n    if (!abortController.signal.aborted) abortController.abort();\n    throw e;\n  }\n\n  // Since the dom might be a fragment or just a text node, we need a wrapper to render it\n  const wrapper = document.createElement(\"div\");\n  wrapper.appendChild(dom);\n\n  // Optional: We should also do a sanity check if we expect full HTML to be created\n  if (\n    wrapper.childNodes.length !== 1 ||\n    wrapper.childNodes[0].nodeType !== 1 ||\n    (wrapper.childNodes[0] as Element).tagName !== \"HTML\"\n  ) {\n    throw new Error(\"Expected one html node at the root level\");\n  }\n\n  return `<!DOCTYPE html>${wrapper.innerHTML}`;\n}\n\nExample\nThe h import is not needed if you use the new JSX Transform!\n// import { h } from \"tsx-dom-ssr\";\n\n// jsx tags (<...>) always return ComponentChildren. These can be used as children or passed to a render function.\nasync function main() {\n  const html = await renderHTML(\n    <html>\n      <head>\n        <title>test</title>\n      </head>\n      <body>\n        <img src=\"my/path.png\" />\n      </body>\n    </html>,\n  );\n  console.log(html);\n}\n\nAttributes and Event Handlers\nSince this is a library for server side rendering, no event listeneres can be defined on the JSX. Frontend code needs to be written separately.\nAll Attributes will be set via element.setAttribute(). Passing true as a value is the same as passing the attribute name as value.\nSpecial Attributes\nSome Attributes have special handling:\n\nclass can be specified either as string, Record<string, boolean> or Array of both. null, undefined and false are valid values as well. Only truthy values count and duplicates will be filtered.\nstyle can be specified either as string or as Object. The latter has obviously the benefit of autocompletion and type checking.\ninnerHTML can only be specified via dangerouslySetInnerHTML, as you should normally avoid this.\n__source and __self have special meaning in JSX and will be ignored. You shouldn't use anything with __ prefix anyway.\n\nChildren\nYou can add as many children as you like. Even deeply nested arrays are allowed and promises as well.\nconst danger = \"Danger\";\nconst someArray = [\"Whoop\", \"Dee\", \"Doo\", 0, 1, 2, [\"nested\", [<i>deeply</i>]]];\nconst promise = Promise.resolve(\"resolved\");\nconst children = (\n  <div>\n    <img src=\"danger.png\" />\n    Will Robinson,\n    {danger}\n    <b>!!!</b>\n    <p>{someArray}</p>\n    <p>{promise}</p>\n  </div>\n);\n\nAs you can see in the example above, even variables can be inserted as children. Promises will be resolved before being inserted. Arrays will be expanded. Falsey values (except 0) will be ignored. ComponentChildren values will be appended as is, string or number values will become text-nodes.\n","title":"HTML Tags","projectIndex":{"title":"tsx-dom-ssr","url":"https://lusito.github.io/tsx-dom/tsx-dom-ssr/"}},{"url":"https://lusito.github.io/tsx-dom/tsx-dom-ssr/setup.html","content":"Setup\nInstall via NPM\nnpm i tsx-dom-ssr\n\nYou will additionally need some kind of DOM environment if you are running tsx-dom-ssr using node. You can use jsdom or happy-dom for example.\nTypeScript Configuration\nEnable TSX parsing in your tsconfig.json:\n{\n  \"compilerOptions\": {\n    \"jsx\": \"react\",\n    \"jsxFactory\": \"h\"\n    // ...\n  }\n  // ...\n}\n\nOr with the new JSX Transform:\n{\n  \"compilerOptions\": {\n    \"jsx\": \"react-jsx\",\n    \"jsxImportSource\": \"tsx-dom-ssr\"\n    // ...\n  }\n  // ...\n}\n\nExamples on how to use it will follow.\n","title":"Setup","projectIndex":{"title":"tsx-dom-ssr","url":"https://lusito.github.io/tsx-dom/tsx-dom-ssr/"}},{"url":"https://lusito.github.io/tsx-dom/tsx-dom-types/","content":"tsx-dom-types\n\nTypes for creating JSX/TSX libraries like tsx-dom or tsx-dom-ssr.\nHow to Use\nCheck out the documentation\nReport Issues\nSomething not working quite as expected? Do you need a feature that has not been implemented yet? Check the issue tracker and add a new one if your problem is not already listed. Please try to provide a detailed description of your problem, including the steps to reproduce it.\nContribute\nAwesome! If you would like to contribute with a new feature or submit a bugfix, fork this repo and send a pull request. Please, make sure all the unit tests are passing before submitting and add new ones in case you introduced new features.\nLicense\ntsx-dom-types has been released under the MIT license, meaning you\ncan use it free of charge, without strings attached in commercial and non-commercial projects. Credits are appreciated but not mandatory.\n","title":"tsx-dom-types","projectIndex":{"title":"tsx-dom-types","url":"https://lusito.github.io/tsx-dom/tsx-dom-types/"}},{"url":"https://lusito.github.io/tsx-dom/tsx-dom-types/setup.html","content":"Setup\nInstall via NPM\nnpm i tsx-dom-types\n\nTo see how to use it, you might want to take a look at the code of tsx-dom.\n","title":"Setup","projectIndex":{"title":"tsx-dom-types","url":"https://lusito.github.io/tsx-dom/tsx-dom-types/"}}]